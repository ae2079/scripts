/**
 * Generate Push Payment Transactions from Stream Data
 * 
 * This script reads the saveStreamDetails output and generates pushPayment transactions
 * that recreate vestings with two separate streams:
 * 1. Immediate vesting (1 second) for claimable tokens
 * 2. Week-long vesting for remaining unvested tokens
 */

import fs from 'fs';
import { ethers } from 'ethers';

// Configuration
const FUNCTION_SELECTORS = {
    pushPayment: "0x8028b82f",
};

const ONE_SECOND = 1;
const ONE_WEEK = 7 * 24 * 60 * 60; // 7 days in seconds
const BATCH_SIZE = 25; // Number of transactions per batch file

// Immediate vesting start timestamp (Unix timestamp in seconds)
// Set to 0 to use current timestamp (start immediately)
// Set to a specific timestamp to start at a future date
// IMPORTANT: Must be in the future when transaction executes!
const IMMEDIATE_VESTING_START_TIMESTAMP = 1760371200; // Same as weekly for Safe approval time

// Weekly vesting start timestamp (Unix timestamp in seconds)
// Set to 0 to use current timestamp (start immediately)
// Set to a specific timestamp to start at a future date
// Example: 1736780000 for January 13, 2025 at 14:40:00 UTC
const WEEKLY_VESTING_START_TIMESTAMP = 1760371200; // Oct 13, 2025 16:00:00 GMT

/**
 * Reads the stream data file generated by fetchUserStreamData.js
 */
function readStreamDataFile(filename) {
    try {
        const data = fs.readFileSync(filename, 'utf8');
        const streamData = JSON.parse(data);
        console.log(`‚úÖ Successfully read stream data file: ${filename}`);
        console.log(`üìä Found ${Object.keys(streamData.users || {}).length} users with stream data`);
        return streamData;
    } catch (error) {
        console.error(`‚ùå Error reading file ${filename}:`, error.message);
        throw error;
    }
}

/**
 * Reads configuration from original transaction file to get addresses and token info
 */
function readConfigFile(filename) {
    try {
        const data = fs.readFileSync(filename, 'utf8');
        const configData = JSON.parse(data);
        console.log(`‚úÖ Successfully read config file: ${filename}`);

        // Extract configuration from the file
        const projectName = configData.projectName;

        // Get Safe address from inputs.projectConfig.SAFE
        const safe = configData.inputs && configData.inputs.projectConfig && configData.inputs.projectConfig.SAFE;

        // Get addresses from queries if available
        const paymentRouter = "0x6B5d37c206D56B16F44b0C1b89002fd9B138e9Be"; // x23ai payment router
        const issuanceToken = configData.queries && configData.queries.addresses && configData.queries.addresses.issuanceToken;

        // Validate required fields
        if (!safe) {
            throw new Error('Safe address not found in config file. Expected at inputs.projectConfig.SAFE');
        }
        if (!paymentRouter) {
            throw new Error('Payment router address not found in config file. Expected at queries.addresses.paymentRouter');
        }
        if (!issuanceToken) {
            throw new Error('Issuance token address not found in config file. Expected at queries.addresses.issuanceToken');
        }

        return {
            projectName,
            safe,
            paymentRouter,
            issuanceToken
        };
    } catch (error) {
        console.error(`‚ùå Error reading config file ${filename}:`, error.message);
        throw error;
    }
}

/**
 * Build pushPayment transactions for a user
 * Creates two vestings:
 * 1. Immediate vesting (1s) for claimable amount
 * 2. Week-long vesting for remaining unvested amount
 */
function buildPushPaymentTransactions(toAddress, userAddress, tokenAddress, immediateAmount, weeklyAmount, startTime, config = {}) {
    const transactions = [];
    const cliffTime = 0; // No cliff

    // Transaction 1: Immediate vesting (1 second duration) for claimable amount
    if (BigInt(immediateAmount) > BigInt(0)) {
        const immediateStartTime = IMMEDIATE_VESTING_START_TIMESTAMP === 0 ? startTime : IMMEDIATE_VESTING_START_TIMESTAMP;
        const endTimeImmediate = immediateStartTime + ONE_SECOND;

        transactions.push({
            to: toAddress,
            value: "0",
            data: FUNCTION_SELECTORS.pushPayment + ethers.AbiCoder.defaultAbiCoder().encode(
                ["address", "address", "uint256", "uint256", "uint256", "uint256"], [userAddress, tokenAddress, immediateAmount, immediateStartTime, cliffTime, endTimeImmediate]
            ).slice(2),
            contractMethod: "pushPayment(address,address,uint256,uint256,uint256,uint256)",
            contractInputsValues: [
                userAddress,
                tokenAddress,
                immediateAmount,
                immediateStartTime.toString(),
                cliffTime.toString(),
                endTimeImmediate.toString()
            ]
        });
    }

    // Transaction 2: Week-long vesting for remaining unvested amount
    if (BigInt(weeklyAmount) > BigInt(0)) {
        const weeklyStartTime = WEEKLY_VESTING_START_TIMESTAMP === 0 ? startTime : WEEKLY_VESTING_START_TIMESTAMP;
        const endTimeWeekly = weeklyStartTime + ONE_WEEK;

        transactions.push({
            to: toAddress,
            value: "0",
            data: FUNCTION_SELECTORS.pushPayment + ethers.AbiCoder.defaultAbiCoder().encode(
                ["address", "address", "uint256", "uint256", "uint256", "uint256"], [userAddress, tokenAddress, weeklyAmount, weeklyStartTime, cliffTime, endTimeWeekly]
            ).slice(2),
            contractMethod: "pushPayment(address,address,uint256,uint256,uint256,uint256)",
            contractInputsValues: [
                userAddress,
                tokenAddress,
                weeklyAmount,
                weeklyStartTime.toString(),
                cliffTime.toString(),
                endTimeWeekly.toString()
            ]
        });
    }

    return transactions;
}

/**
 * Process stream data and generate transactions for all users
 */
function processStreamData(streamData, config) {
    const users = streamData.users || {};
    const userTransactions = [];

    let usersWithStreams = 0;
    let usersSkipped = 0;
    let totalImmediateAmount = BigInt(0);
    let totalWeeklyAmount = BigInt(0);

    console.log('\nüìä Processing stream data...\n');

    for (const [userAddress, userData] of Object.entries(users)) {
        // Skip users with no streams or errors
        if (!userData.streams || userData.streams.length === 0 || userData.error) {
            usersSkipped++;
            console.log(`‚è≠Ô∏è  Skipping ${userAddress}: ${userData.error || 'No streams found'}`);
            continue;
        }

        // Aggregate all streams for the user
        let totalAmount = BigInt(0);
        let totalReleased = BigInt(0);
        let totalReleasable = BigInt(0);
        let tokenAddress = null;

        for (const stream of userData.streams) {
            if (stream.releasable === "ERROR") {
                console.log(`‚ö†Ô∏è  Warning: Stream ${stream.streamId} for ${userAddress} has error in releasable amount`);
                continue;
            }

            totalAmount += BigInt(stream.amount);
            totalReleased += BigInt(stream.released);
            totalReleasable += BigInt(stream.releasable);
            tokenAddress = tokenAddress || stream.token;
        }

        // Calculate amounts for new vestings
        const immediateAmount = totalReleasable;
        const weeklyAmount = totalAmount - totalReleased - totalReleasable;

        // Skip if no amounts to vest
        if (immediateAmount === BigInt(0) && weeklyAmount === BigInt(0)) {
            usersSkipped++;
            console.log(`‚è≠Ô∏è  Skipping ${userAddress}: No amounts to vest (all claimed or zero)`);
            continue;
        }

        // Use checksummed addresses
        const checksummedUserAddress = ethers.getAddress(userAddress);
        const checksummedTokenAddress = ethers.getAddress(tokenAddress);

        // Generate transactions for this user
        const startTime = Math.floor(Date.now() / 1000); // Current timestamp
        const transactions = buildPushPaymentTransactions(
            config.paymentRouter,
            checksummedUserAddress,
            checksummedTokenAddress,
            immediateAmount.toString(),
            weeklyAmount.toString(),
            startTime,
            config
        );

        if (transactions.length > 0) {
            userTransactions.push({
                user: checksummedUserAddress,
                transactions,
                summary: {
                    totalAmount: totalAmount.toString(),
                    released: totalReleased.toString(),
                    releasable: totalReleasable.toString(),
                    immediateVesting: immediateAmount.toString(),
                    weeklyVesting: weeklyAmount.toString()
                }
            });

            usersWithStreams++;
            totalImmediateAmount += immediateAmount;
            totalWeeklyAmount += weeklyAmount;

            console.log(`‚úÖ ${checksummedUserAddress}:`);
            console.log(`   Total: ${ethers.formatUnits(totalAmount, 18)} tokens`);
            console.log(`   Already claimed: ${ethers.formatUnits(totalReleased, 18)} tokens`);
            console.log(`   Claimable now: ${ethers.formatUnits(immediateAmount, 18)} tokens (1s vesting)`);
            console.log(`   Unvested: ${ethers.formatUnits(weeklyAmount, 18)} tokens (1 week vesting)`);
        }
    }

    console.log(`\nüìà Summary:`);
    console.log(`   Users processed: ${usersWithStreams}`);
    console.log(`   Users skipped: ${usersSkipped}`);
    console.log(`   Total immediate vesting: ${ethers.formatUnits(totalImmediateAmount, 18)} tokens`);
    console.log(`   Total weekly vesting: ${ethers.formatUnits(totalWeeklyAmount, 18)} tokens`);
    console.log(`   Total tokens: ${ethers.formatUnits(totalImmediateAmount + totalWeeklyAmount, 18)} tokens\n`);

    return userTransactions;
}

/**
 * Generate transaction JSON files in Safe Transaction Builder format
 */
function generateTransactionFiles(projectName, safeAddress, userTransactions) {
    // Flatten all transactions
    const allTransactions = [];
    for (const userTx of userTransactions) {
        allTransactions.push(...userTx.transactions);
    }

    const totalTransactions = allTransactions.length;
    const totalBatches = Math.ceil(totalTransactions / BATCH_SIZE);
    const currentTimestamp = Date.now();

    // Create project folder structure (one level up since we're in a subfolder)
    const projectFolder = `${projectName}`;
    const pushPaymentFolder = `${projectFolder}/pushPayment`;

    if (!fs.existsSync(projectFolder)) {
        fs.mkdirSync(projectFolder, { recursive: true });
        console.log(`üìÅ Created project folder: ${projectFolder}`);
    }

    if (!fs.existsSync(pushPaymentFolder)) {
        fs.mkdirSync(pushPaymentFolder, { recursive: true });
        console.log(`üìÅ Created pushPayment folder: ${pushPaymentFolder}`);
    }

    const checksummedSafeAddress = ethers.getAddress(safeAddress);

    console.log(`\nüìù Generating ${totalBatches} batch file(s) for ${totalTransactions} transactions...\n`);

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
        const startIndex = batchIndex * BATCH_SIZE;
        const endIndex = Math.min(startIndex + BATCH_SIZE, totalTransactions);
        const batchTransactions = allTransactions.slice(startIndex, endIndex);

        const transactionData = {
            version: "1.0",
            chainId: "137", // Polygon Mainnet
            createdAt: currentTimestamp,
            meta: {
                name: `[PUSH-PAYMENTS]-[${projectName}]-[STREAM-RESET]-[TX-${batchIndex}]`,
                description: `Batch ${batchIndex + 1} for ${projectName} - Stream reset with immediate + weekly vestings`,
                txBuilderVersion: "",
                createdFromSafeAddress: checksummedSafeAddress,
                createdFromOwnerAddress: "",
                checksum: ""
            },
            transactions: batchTransactions
        };

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').replace('T', '_').slice(0, 19);
        const filename = `transactions_${projectName}_batch${batchIndex + 1}_${timestamp}.json`;
        const filePath = `${pushPaymentFolder}/${filename}`;

        fs.writeFileSync(filePath, JSON.stringify(transactionData, null, 2));
        console.log(`‚úÖ Generated: ${filename} (${batchTransactions.length} transactions)`);
    }

    console.log(`\nüéâ All transaction files generated successfully!`);
}

// Main execution
async function main() {
    try {
        console.log('\nüöÄ Starting Push Payment Transaction Generator from Stream Data\n');
        console.log('='.repeat(80) + '\n');

        // CONFIGURATION - Update these file paths as needed
        const streamDataFile = 'stream_data.json'; // Path to saveStreamDetails output
        const configFile = '1.json'; // Path to original transaction file for config

        console.log('üìñ Reading input files...\n');

        // Read configuration from original transaction file
        const config = readConfigFile(configFile);
        console.log(`üìã Project: ${config.projectName}`);
        console.log(`üîí Safe: ${config.safe}`);
        console.log(`üìç Payment Router: ${config.paymentRouter}`);
        console.log(`ü™ô Token: ${config.issuanceToken}`);
        if (IMMEDIATE_VESTING_START_TIMESTAMP === 0) {
            console.log(`‚è±Ô∏è  Immediate vesting start: Current timestamp (immediate)`);
        } else {
            const date = new Date(IMMEDIATE_VESTING_START_TIMESTAMP * 1000);
            console.log(`‚è±Ô∏è  Immediate vesting start: ${IMMEDIATE_VESTING_START_TIMESTAMP} (${date.toISOString()})`);
        }
        if (WEEKLY_VESTING_START_TIMESTAMP === 0) {
            console.log(`‚è±Ô∏è  Weekly vesting start: Current timestamp (immediate)`);
        } else {
            const date = new Date(WEEKLY_VESTING_START_TIMESTAMP * 1000);
            console.log(`‚è±Ô∏è  Weekly vesting start: ${WEEKLY_VESTING_START_TIMESTAMP} (${date.toISOString()})`);
        }
        console.log();

        // Read stream data
        const streamData = readStreamDataFile(streamDataFile);

        // Process stream data and generate transactions
        const userTransactions = processStreamData(streamData, config);

        if (userTransactions.length === 0) {
            console.log('\n‚ö†Ô∏è  No transactions to generate. All users were skipped.');
            return;
        }

        // Generate transaction files
        generateTransactionFiles(config.projectName, config.safe, userTransactions);

        console.log('\n‚úÖ Done!');
        console.log('\nüí° Next steps:');
        console.log('   1. Review the generated transaction files');
        console.log('   2. Use the SafeTransactionProposer to propose these transactions');
        console.log(`   3. Run: cd SafeTransactionProposer && npm run propose:batch ../${config.projectName}/pushPayment\n`);

    } catch (error) {
        console.error('\n‚ùå Fatal error:', error);
        process.exit(1);
    }
}

// Run the script
main();