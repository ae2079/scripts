import fs from 'fs';
import { ethers } from 'ethers';

// ============================================================================
// CONFIGURATION
// ============================================================================
const CONFIG = {
    // Can be a single file or an array of files
    transactionFileNames: [
        "5.json",
        "1.json",
        "2.json",
        "3.json",
        "4.json",
    ],
    claimsReportFileName: "claims_report.json",
    onlyUsersWithClaims: false, // Set to true to only process users who have claimed

    // New stream configuration
    newStreamStartTimestamp: 1762736400, // Set to 0 to use current time, or specify Unix timestamp
    // When 0: Uses Math.floor(Date.now() / 1000)
    // Example: 1760371200 for Oct 13, 2025 16:00:00 GMT
};

const FUNCTION_SELECTORS = {
    pushPayment: "0x8028b82f",
};

const ONE_SECOND = 1;
const ONE_WEEK = 7 * 24 * 60 * 60; // 7 days in seconds

// ============================================================================
// FILE OPERATIONS
// ============================================================================

/**
 * Reads a single transaction file
 */
function readTransactionFile(filename) {
    try {
        const data = fs.readFileSync(filename, 'utf8');
        const fileData = JSON.parse(data);
        console.log(`   ‚úÖ ${filename}: ${fileData.transactions?.readable?.length || 0} transactions`);
        return fileData;
    } catch (error) {
        console.error(`‚ùå Error reading ${filename}:`, error.message);
        return null;
    }
}

/**
 * Reads multiple transaction files
 */
function readTransactionFiles(fileNames) {
    console.log(`\nüìÑ Reading transaction files...`);

    // Convert single filename to array
    const fileNameArray = Array.isArray(fileNames) ? fileNames : [fileNames];

    const allFilesData = [];
    let totalTransactions = 0;

    for (const filename of fileNameArray) {
        const fileData = readTransactionFile(filename);
        if (fileData) {
            allFilesData.push(fileData);
            totalTransactions += fileData.transactions ? fileData.transactions.readable ? fileData.transactions.readable.length : 0 : 0;
        }
    }

    if (allFilesData.length === 0) {
        throw new Error('No transaction files found');
    }

    console.log(`\nüìà Summary: ${allFilesData.length} file(s) loaded, ${totalTransactions} total transactions`);

    // Use the first file's configuration
    // Note: All files should have the same projectName, Safe, paymentRouter, and token
    return allFilesData;
}

/**
 * Reads the claims report generated by generateClaimsReport.js
 */
function readClaimsReport(filename) {
    try {
        const data = fs.readFileSync(filename, 'utf8');
        const claimsReport = JSON.parse(data);
        console.log(`‚úÖ Successfully read claims report: ${filename}`);
        console.log(`üìä Found ${claimsReport.totalUsers} users with ${claimsReport.totalClaims} claims`);
        return claimsReport;
    } catch (error) {
        if (error.code === 'ENOENT') {
            console.log(`‚ö†Ô∏è  Claims report not found: ${filename}`);
            console.log(`   Run 'npm run generate-claims-report' first to generate the report`);
            return null;
        }
        console.error(`‚ùå Error reading claims report ${filename}:`, error.message);
        throw error;
    }
}

// ============================================================================
// DATA EXTRACTION
// ============================================================================

/**
 * Extract user data from transactions and merge duplicates within the same file
 */
function getUserDataFromTransactions(transactions) {
    const userMap = new Map();

    for (const transaction of transactions) {
        for (const tx of transaction) {
            if (tx.functionSignature === "pushPayment(address,address,uint256,uint256,uint256,uint256)") {
                const userAddress = tx.inputValues[0].toLowerCase();
                const amount = BigInt(tx.inputValues[2]);

                if (userMap.has(userAddress)) {
                    // User already exists, sum the amounts
                    const existing = userMap.get(userAddress);
                    existing.amount = (BigInt(existing.amount) + amount).toString();
                } else {
                    // New user
                    userMap.set(userAddress, {
                        address: tx.inputValues[0], // Keep original checksum
                        amount: amount.toString(),
                    });
                }
            }
        }
    }

    return Array.from(userMap.values());
}

/**
 * Extract user data with vesting information from a single file
 */
function getUserDataWithVestingFromFile(fileData) {
    const users = getUserDataFromTransactions(fileData.transactions.readable);

    // Get timing from first transaction
    let originalStart, originalCliff, originalEnd;
    if (fileData.transactions.readable && fileData.transactions.readable.length > 0) {
        const firstTransaction = fileData.transactions.readable[0];
        if (firstTransaction && firstTransaction.length > 0) {
            const firstTx = firstTransaction.find(tx =>
                tx.functionSignature === "pushPayment(address,address,uint256,uint256,uint256,uint256)"
            );
            if (firstTx && firstTx.inputValues && firstTx.inputValues.length >= 6) {
                originalStart = parseInt(firstTx.inputValues[3]);
                originalCliff = parseInt(firstTx.inputValues[4]);
                originalEnd = parseInt(firstTx.inputValues[5]);
            }
        }
    }

    const transactionCount = fileData.transactions.readable.reduce((sum, txArray) => sum + txArray.length, 0);
    if (users.length < transactionCount) {
        const merged = transactionCount - users.length;
        console.log(`   üìä ${transactionCount} transactions ‚Üí ${users.length} unique users (${merged} duplicates merged)`);
    }

    return {
        users,
        timing: { originalStart, originalCliff, originalEnd }
    };
}

// ============================================================================
// VESTING CALCULATIONS
// ============================================================================

/**
 * Calculate how much would be releasable at a given timestamp
 */
function calculateReleasableAmount(totalAmount, vestingStart, vestingEnd, currentTime) {
    const total = BigInt(totalAmount);
    const start = BigInt(vestingStart);
    const end = BigInt(vestingEnd);
    const now = BigInt(currentTime);

    // If before vesting starts, nothing is releasable
    if (now < start) {
        return BigInt(0);
    }

    // If after vesting ends, everything is releasable
    if (now >= end) {
        return total;
    }

    // Linear vesting: releasable = total * (now - start) / (end - start)
    const elapsed = now - start;
    const duration = end - start;

    if (duration === BigInt(0)) {
        return total;
    }

    return (total * elapsed) / duration;
}

/**
 * Merge users across all files, calculating total releasable amount from all streams
 */
function mergeUsersAcrossFiles(filesDataArray, newStreamStart) {
    const userMap = new Map();
    let filesProcessed = 0;

    console.log(`\nüìä Merging users across all files...`);

    for (let i = 0; i < filesDataArray.length; i++) {
        const fileData = filesDataArray[i];
        const fileName = Array.isArray(CONFIG.transactionFileNames) ?
            CONFIG.transactionFileNames[i] :
            CONFIG.transactionFileNames;

        const { users, timing } = getUserDataWithVestingFromFile(fileData);

        if (!timing.originalStart || !timing.originalEnd) {
            console.log(`   ‚ö†Ô∏è  Skipping ${fileName}: Failed to extract timing`);
            continue;
        }

        const actualVestingStart = timing.originalStart + timing.originalCliff;
        filesProcessed++;

        console.log(`   üìÑ ${fileName}: ${users.length} users, vesting ${new Date(actualVestingStart * 1000).toISOString().split('T')[0]} to ${new Date(timing.originalEnd * 1000).toISOString().split('T')[0]}`);

        // For each user in this file, add their releasable and unvested amounts
        for (const user of users) {
            const userKey = user.address.toLowerCase();
            const amount = BigInt(user.amount);

            // Calculate releasable and unvested for THIS stream
            const releasable = calculateReleasableAmount(
                amount,
                actualVestingStart,
                timing.originalEnd,
                newStreamStart
            );
            const unvested = amount - releasable;

            if (userMap.has(userKey)) {
                // User exists in multiple files - sum their amounts
                const existing = userMap.get(userKey);
                existing.totalAmount = (BigInt(existing.totalAmount) + amount).toString();
                existing.totalReleasable = (BigInt(existing.totalReleasable) + releasable).toString();
                existing.totalUnvested = (BigInt(existing.totalUnvested) + unvested).toString();
                existing.streamCount++;
            } else {
                // New user
                userMap.set(userKey, {
                    address: user.address,
                    totalAmount: amount.toString(),
                    totalReleasable: releasable.toString(),
                    totalUnvested: unvested.toString(),
                    streamCount: 1
                });
            }
        }
    }

    const finalUsers = Array.from(userMap.values());
    const usersWithMultipleStreams = finalUsers.filter(u => u.streamCount > 1).length;

    console.log(`\n‚úÖ Merge Complete:`);
    console.log(`   Files processed: ${filesProcessed}`);
    console.log(`   Total unique users: ${finalUsers.length}`);
    console.log(`   Users with multiple streams: ${usersWithMultipleStreams}`);

    return finalUsers;
}

/**
 * Build a map of claimed amounts from the claims report
 */
function buildClaimedAmountsMap(claimsReport, tokenAddress) {
    const claimedMap = new Map();
    const tokenAddressLower = tokenAddress.toLowerCase();

    for (const userEntry of claimsReport.users) {
        const userAddressLower = userEntry.userAddress.toLowerCase();

        for (const tokenEntry of userEntry.tokens) {
            if (tokenEntry.tokenAddress.toLowerCase() === tokenAddressLower) {
                claimedMap.set(userAddressLower, {
                    claimedAmount: tokenEntry.totalClaimed,
                    claimCount: tokenEntry.claimCount
                });
                break;
            }
        }
    }

    return claimedMap;
}

// ============================================================================
// TRANSACTION BUILDING
// ============================================================================

/**
 * Build push payment transactions with two streams using pre-calculated totals
 */
function buildTransactions(toAddress, userData, tokenAddress, newStreamStart, claimedMap, onlyUsersWithClaims) {
    const transactions = [];
    let usersProcessed = 0;
    let usersWithClaims = 0;
    let usersSkipped = 0;
    let totalDeducted = BigInt(0);
    let totalImmediateVesting = BigInt(0);
    let totalWeeklyVesting = BigInt(0);

    // Checksum addresses to ensure proper format
    const checksummedToAddress = ethers.getAddress(toAddress);
    const checksummedTokenAddress = ethers.getAddress(tokenAddress);

    console.log('\nüìä Processing merged users and applying claim deductions...\n');
    console.log(`‚è∞ New streams start: ${new Date(newStreamStart * 1000).toISOString()}\n`);

    for (const user of userData) {
        const checksummedUserAddress = ethers.getAddress(user.address);
        const userAddressLower = user.address.toLowerCase();

        const totalAmount = BigInt(user.totalAmount);
        let totalReleasable = BigInt(user.totalReleasable);
        let totalUnvested = BigInt(user.totalUnvested);
        let shouldInclude = !onlyUsersWithClaims;

        // Check if user has claimed and deduct from releasable
        let claimedAmount = BigInt(0);
        let immediateAmount = totalReleasable;

        const claimData = claimedMap.get(userAddressLower);
        if (claimData) {
            usersWithClaims++;
            claimedAmount = BigInt(claimData.claimedAmount);

            // Deduct claimed from releasable first
            immediateAmount = totalReleasable - claimedAmount;

            // If user claimed more than releasable, they over-claimed
            // Set immediate to 0 and deduct excess from unvested
            if (immediateAmount < BigInt(0)) {
                const excessClaimed = claimedAmount - totalReleasable;
                totalUnvested = totalUnvested - excessClaimed;
                immediateAmount = BigInt(0);

                // Ensure unvested doesn't go negative
                if (totalUnvested < BigInt(0)) {
                    totalUnvested = BigInt(0);
                }
            }

            totalDeducted += claimedAmount;

            if (onlyUsersWithClaims) {
                shouldInclude = true;
            }

            console.log(`üí∞ ${checksummedUserAddress}${user.streamCount > 1 ? ` (${user.streamCount} streams merged)` : ''}:`);
            console.log(`   Total amount: ${ethers.formatEther(totalAmount)} tokens`);
            console.log(`   Releasable at new start: ${ethers.formatEther(totalReleasable)} tokens`);
            console.log(`   Already claimed: ${ethers.formatEther(claimedAmount)} tokens`);
            if (claimedAmount > totalReleasable) {
                console.log(`   ‚ö†Ô∏è  Over-claimed by: ${ethers.formatEther(claimedAmount - totalReleasable)} tokens`);
            }
            console.log(`   ‚Üí Immediate vesting (1s): ${ethers.formatEther(immediateAmount)} tokens`);
            console.log(`   ‚Üí Weekly vesting (7d): ${ethers.formatEther(totalUnvested)} tokens\n`);
        }

        // Skip if both amounts are zero or negative
        if (immediateAmount <= BigInt(0) && totalUnvested <= BigInt(0)) {
            usersSkipped++;
            console.log(`‚è≠Ô∏è  Skipping ${checksummedUserAddress}: Fully claimed\n`);
            continue;
        }

        // Include user if they should be included
        if (shouldInclude) {
            // Transaction 1: Immediate vesting (1 second) for claimable amount
            if (immediateAmount > BigInt(0)) {
                const endTimeImmediate = newStreamStart + ONE_SECOND;

                transactions.push({
                    to: checksummedToAddress,
                    value: "0",
                    data: FUNCTION_SELECTORS.pushPayment + ethers.AbiCoder.defaultAbiCoder().encode(
                        ["address", "address", "uint256", "uint256", "uint256", "uint256"], [checksummedUserAddress, checksummedTokenAddress, immediateAmount.toString(), newStreamStart, 0, endTimeImmediate]
                    ).slice(2),
                    contractMethod: "pushPayment(address,address,uint256,uint256,uint256,uint256)",
                    contractInputsValues: [
                        checksummedUserAddress,
                        checksummedTokenAddress,
                        immediateAmount.toString(),
                        newStreamStart.toString(),
                        "0",
                        endTimeImmediate.toString()
                    ]
                });
                totalImmediateVesting += immediateAmount;
            }

            // Transaction 2: Week-long vesting for remaining unvested amount
            if (totalUnvested > BigInt(0)) {
                const endTimeWeekly = newStreamStart + ONE_WEEK;

                transactions.push({
                    to: checksummedToAddress,
                    value: "0",
                    data: FUNCTION_SELECTORS.pushPayment + ethers.AbiCoder.defaultAbiCoder().encode(
                        ["address", "address", "uint256", "uint256", "uint256", "uint256"], [checksummedUserAddress, checksummedTokenAddress, totalUnvested.toString(), newStreamStart, 0, endTimeWeekly]
                    ).slice(2),
                    contractMethod: "pushPayment(address,address,uint256,uint256,uint256,uint256)",
                    contractInputsValues: [
                        checksummedUserAddress,
                        checksummedTokenAddress,
                        totalUnvested.toString(),
                        newStreamStart.toString(),
                        "0",
                        endTimeWeekly.toString()
                    ]
                });
                totalWeeklyVesting += totalUnvested;
            }

            usersProcessed++;
        }
    }

    console.log('='.repeat(80));
    console.log('üìà Processing Summary:');
    console.log('='.repeat(80));
    console.log(`Total users in files: ${userData.length}`);
    console.log(`Users with claims: ${usersWithClaims}`);
    console.log(`Users without claims: ${userData.length - usersWithClaims}`);
    console.log(`Users processed: ${usersProcessed}`);
    console.log(`Users skipped (fully claimed): ${usersSkipped}`);
    console.log(`Total claimed amount deducted: ${ethers.formatEther(totalDeducted)} tokens`);
    console.log(`Total immediate vesting (1s): ${ethers.formatEther(totalImmediateVesting)} tokens`);
    console.log(`Total weekly vesting (7d): ${ethers.formatEther(totalWeeklyVesting)} tokens`);
    console.log(`Total tokens in new streams: ${ethers.formatEther(totalImmediateVesting + totalWeeklyVesting)} tokens\n`);

    return transactions;
}

/**
 * Generate transaction JSON files in batches
 */
function generateTransactionJsonSimple(safe, projectName, transactions) {
    const batchSize = 25;
    const currentTimestamp = Date.now();

    // Checksum the Safe address
    const checksummedSafeAddress = ethers.getAddress(safe);

    // Create project folder structure
    const projectFolder = `./${projectName}`;
    const pushPaymentFolder = `${projectFolder}/pushPayment`;

    if (!fs.existsSync(projectFolder)) {
        fs.mkdirSync(projectFolder, { recursive: true });
        console.log(`üìÅ Created project folder: ${projectFolder}`);
    }

    if (!fs.existsSync(pushPaymentFolder)) {
        fs.mkdirSync(pushPaymentFolder, { recursive: true });
        console.log(`üìÅ Created pushPayment folder: ${pushPaymentFolder}`);
    }

    // Split into batches
    const totalBatches = Math.ceil(transactions.length / batchSize);

    console.log(`Batch size: 25`);
    console.log(`Total batches: ${totalBatches}\n`);

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
        const startIndex = batchIndex * batchSize;
        const endIndex = Math.min(startIndex + batchSize, transactions.length);
        const batchTransactions = transactions.slice(startIndex, endIndex);

        const transactionData = {
            version: "1.0",
            chainId: "137", // Polygon Mainnet
            createdAt: currentTimestamp,
            meta: {
                name: `[PUSH-PAYMENTS]-[${projectName}]-[DUAL-STREAM]-[TX-${batchIndex}]`,
                description: `Batch ${batchIndex + 1} for ${projectName} - Immediate (1s) + Weekly (7d) vestings with claim deductions`,
                txBuilderVersion: "",
                createdFromSafeAddress: checksummedSafeAddress,
                createdFromOwnerAddress: "",
                checksum: ""
            },
            transactions: batchTransactions
        };

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').replace('T', '_').slice(0, 19);
        const filename = `transactions_${projectName}_batch${batchIndex + 1}_${timestamp}.json`;
        const filePath = `${pushPaymentFolder}/${filename}`;

        fs.writeFileSync(filePath, JSON.stringify(transactionData, null, 2));
        console.log(`‚úÖ Generated: ${filename} (${batchTransactions.length} transactions)`);
    }

    console.log(`\nüéâ All transaction files generated successfully!`);
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

async function main() {
    console.log('='.repeat(80));
    console.log('Push Payment Transaction Generator with Claim Deduction');
    console.log('='.repeat(80));

    // Read transaction files
    const filesDataArray = readTransactionFiles(CONFIG.transactionFileNames);

    // Use FIRST file for configuration
    const firstFileData = filesDataArray[0];
    let projectName = firstFileData.projectName;
    const paymentRouterAddress = firstFileData.queries.addresses.paymentRouter;
    const fundingPotMSAddress = firstFileData.inputs.projectConfig.SAFE;
    const abcTokenAddress = firstFileData.queries.addresses.issuanceToken;

    // Clean up project name
    if (projectName) {
        const originalName = projectName;
        projectName = projectName.replace(/_S2$/i, '').replace(/_+$/, '');
        if (originalName !== projectName) {
            console.log(`\nüìù Cleaned project name: ${originalName} ‚Üí ${projectName}`);
        }
    }

    // Validate extracted data
    if (!projectName || !paymentRouterAddress || !fundingPotMSAddress || !abcTokenAddress) {
        console.error('\n‚ùå Error: Failed to extract all required configuration from first transaction file');
        console.error('Missing:', {
            projectName: !!projectName,
            paymentRouterAddress: !!paymentRouterAddress,
            fundingPotMSAddress: !!fundingPotMSAddress,
            abcTokenAddress: !!abcTokenAddress
        });
        process.exit(1);
    }

    console.log('\n‚úÖ Project Configuration (from first file):');
    console.log(`   Project Name: ${projectName}`);
    console.log(`   Safe Address: ${fundingPotMSAddress}`);
    console.log(`   Payment Router: ${paymentRouterAddress}`);
    console.log(`   Token Address: ${abcTokenAddress}`);

    // Calculate new stream start time
    const newStreamStart = CONFIG.newStreamStartTimestamp === 0 ?
        Math.floor(Date.now() / 1000) :
        CONFIG.newStreamStartTimestamp;

    console.log(`\n‚è∞ New Streams Configuration:`);
    console.log(`   Start: ${newStreamStart} (${new Date(newStreamStart * 1000).toISOString()})`);
    console.log(`   ‚Üí Immediate Vesting: 1 second duration`);
    console.log(`   ‚Üí Weekly Vesting: 7 days duration`);

    // Merge users across all files, calculating total releasable from all streams
    const mergedUsers = mergeUsersAcrossFiles(filesDataArray, newStreamStart);

    // Read claims report
    console.log(`\nüìä Reading claims report: ${CONFIG.claimsReportFileName}`);
    const claimsReport = readClaimsReport(CONFIG.claimsReportFileName);

    // Build claimed amounts map
    const claimedMap = claimsReport ? buildClaimedAmountsMap(claimsReport, abcTokenAddress) : new Map();

    if (claimedMap.size > 0) {
        console.log(`‚úÖ Found ${claimedMap.size} users with claims for this token`);
    } else {
        console.log(`‚ö†Ô∏è  No claims found - will use calculated releasable amounts without deductions`);
    }

    // Generate transactions
    console.log('\n' + '='.repeat(80));
    console.log('üèóÔ∏è  Generating Dual-Stream Transactions');
    console.log('='.repeat(80));
    console.log(`Mode: ${CONFIG.onlyUsersWithClaims ? 'Only users with claims' : 'All users'}`);
    console.log(`Strategy: Merge all streams, one pair per user (immediate + weekly)`);

    const transactions = buildTransactions(
        paymentRouterAddress,
        mergedUsers,
        abcTokenAddress,
        newStreamStart,
        claimedMap,
        CONFIG.onlyUsersWithClaims
    );

    if (transactions.length === 0) {
        console.log('\n‚ö†Ô∏è  No transactions to generate. All users were skipped.');
        return;
    }

    // Generate output files
    console.log('\n' + '='.repeat(80));
    console.log('üìù Generating Transaction Files');
    console.log('='.repeat(80));

    generateTransactionJsonSimple(fundingPotMSAddress, projectName, transactions);

    console.log('\n‚úÖ Done!');
    console.log('='.repeat(80));
}

main().catch(error => {
    console.error('\n‚ùå Fatal Error:', error);
    process.exit(1);
});