import fs from 'fs';
import { ethers } from 'ethers';

// ============================================================================
// CONFIGURATION
// ============================================================================
const CONFIG = {
    // Can be a single file or an array of files
    transactionFileNames: [
        "5.json",
        // Add more transaction files here if needed
        // "1.json",
        // "2.json",
        // "3.json",
        // "4.json",
    ],
    claimsReportFileName: "claims_report.json",
    onlyUsersWithClaims: false // Set to true to only process users who have claimed
};

const FUNCTION_SELECTORS = {
    pushPayment: "0x8028b82f",
};

// ============================================================================
// FILE OPERATIONS
// ============================================================================

/**
 * Reads a single transaction file containing user payment data
 */
function readTransactionFile(filename) {
    try {
        const data = fs.readFileSync(filename, 'utf8');
        const transactionData = JSON.parse(data);
        console.log(`   ‚úÖ ${filename}: ${transactionData.transactions?.readable?.length || 0} transactions`);
        return transactionData;
    } catch (error) {
        if (error.code === 'ENOENT') {
            console.log(`   ‚ö†Ô∏è  Not found: ${filename}`);
            return null;
        }
        console.error(`   ‚ùå Error reading ${filename}:`, error.message);
        throw error;
    }
}

/**
 * Reads multiple transaction files and merges them
 */
function readTransactionFiles(fileNames) {
    console.log(`\nüìÑ Reading transaction files...`);

    // Convert single filename to array
    const fileNameArray = Array.isArray(fileNames) ? fileNames : [fileNames];

    const allFilesData = [];
    let totalTransactions = 0;

    for (const filename of fileNameArray) {
        const fileData = readTransactionFile(filename);
        if (fileData) {
            allFilesData.push(fileData);
            totalTransactions += fileData.transactions ? fileData.transactions.readable ? fileData.transactions.readable.length : 0 : 0;
        }
    }

    if (allFilesData.length === 0) {
        throw new Error('No transaction files found');
    }

    console.log(`\nüìà Summary: ${allFilesData.length} file(s) loaded, ${totalTransactions} total transactions`);

    // Use the first file's configuration
    // Note: All files should have the same projectName, Safe, paymentRouter, and token
    return allFilesData;
}

/**
 * Reads the claims report generated by generateClaimsReport.js
 */
function readClaimsReport(filename) {
    try {
        const data = fs.readFileSync(filename, 'utf8');
        const claimsReport = JSON.parse(data);
        console.log(`‚úÖ Successfully read claims report: ${filename}`);
        console.log(`üìä Found ${claimsReport.totalUsers} users with ${claimsReport.totalClaims} claims`);
        return claimsReport;
    } catch (error) {
        if (error.code === 'ENOENT') {
            console.log(`‚ö†Ô∏è  Claims report not found: ${filename}`);
            console.log(`   Run 'npm run generate-claims-report' first to generate the report`);
            return null;
        }
        console.error(`‚ùå Error reading claims report ${filename}:`, error.message);
        throw error;
    }
}

/**
 * Extract user data from transactions
 */
function getUserDataFromTransactions(transactions) {
    const userData = [];
    for (const transaction of transactions) {
        for (const tx of transaction) {
            if (tx.functionSignature === "pushPayment(address,address,uint256,uint256,uint256,uint256)") {
                userData.push({
                    address: tx.inputValues[0],
                    amount: tx.inputValues[2],
                });
            }
        }
    }
    return userData;
}

/**
 * Extract and merge user data from multiple transaction files
 */
function getUserDataFromMultipleFiles(filesDataArray) {
    const userMap = new Map();

    for (const fileData of filesDataArray) {
        const users = getUserDataFromTransactions(fileData.transactions.readable);

        // Merge users, summing amounts for duplicates
        for (const user of users) {
            const userKey = user.address.toLowerCase();
            if (userMap.has(userKey)) {
                const existing = userMap.get(userKey);
                existing.amount = (BigInt(existing.amount) + BigInt(user.amount)).toString();
            } else {
                userMap.set(userKey, {
                    address: user.address,
                    amount: user.amount
                });
            }
        }
    }

    return Array.from(userMap.values());
}

/**
 * Build a map of claimed amounts from the claims report
 */
function buildClaimedAmountsMap(claimsReport, tokenAddress) {
    const claimedMap = new Map();

    if (!claimsReport || !claimsReport.users) {
        return claimedMap;
    }

    const normalizedTokenAddress = tokenAddress.toLowerCase();

    for (const user of claimsReport.users) {
        const userAddress = user.userAddress.toLowerCase();

        // Find the token in user's tokens
        const tokenData = user.tokens.find(t =>
            t.tokenAddress.toLowerCase() === normalizedTokenAddress
        );

        if (tokenData && BigInt(tokenData.totalClaimed) > BigInt(0)) {
            claimedMap.set(userAddress, {
                address: user.userAddress,
                claimedAmount: tokenData.totalClaimed,
                claimCount: tokenData.claimCount
            });
        }
    }

    return claimedMap;
}

// ============================================================================
// TRANSACTION BUILDING
// ============================================================================

/**
 * Build push payment transactions with claim deductions
 */
function buildTransactions(toAddress, userData, tokenAddress, start, cliff, end, claimedMap, onlyUsersWithClaims) {
    const transactions = [];
    let usersProcessed = 0;
    let usersWithClaims = 0;
    let usersSkipped = 0;
    let totalDeducted = BigInt(0);

    // Checksum addresses to ensure proper format
    const checksummedToAddress = ethers.getAddress(toAddress);
    const checksummedTokenAddress = ethers.getAddress(tokenAddress);

    console.log('\nüìä Processing users...\n');

    for (const user of userData) {
        const checksummedUserAddress = ethers.getAddress(user.address);
        const userAddressLower = user.address.toLowerCase();

        let amountToPush = user.amount;
        let shouldInclude = !onlyUsersWithClaims;

        // Check if user has claimed
        const claimData = claimedMap.get(userAddressLower);

        if (claimData) {
            usersWithClaims++;
            const claimedAmount = BigInt(claimData.claimedAmount);
            const originalAmount = BigInt(user.amount);

            console.log(`üí∞ ${checksummedUserAddress}:`);
            console.log(`   Original amount: ${ethers.formatEther(originalAmount)} tokens`);
            console.log(`   Claimed amount: ${ethers.formatEther(claimedAmount)} tokens (${claimData.claimCount} claims)`);

            amountToPush = (originalAmount - claimedAmount).toString();
            totalDeducted += claimedAmount;

            console.log(`   ‚Üí New amount: ${ethers.formatEther(amountToPush)} tokens\n`);

            if (onlyUsersWithClaims) {
                shouldInclude = true;
            }
        }

        // Include user if they should be included and have a positive amount
        if (shouldInclude && BigInt(amountToPush) > BigInt(0)) {
            transactions.push({
                to: checksummedToAddress,
                value: "0",
                data: FUNCTION_SELECTORS.pushPayment + ethers.AbiCoder.defaultAbiCoder().encode(
                    ["address", "address", "uint256", "uint256", "uint256", "uint256"], [checksummedUserAddress, checksummedTokenAddress, amountToPush, start, cliff, end]
                ).slice(2),
                contractMethod: "pushPayment(address,address,uint256,uint256,uint256,uint256)",
                contractInputsValues: [
                    checksummedUserAddress,
                    checksummedTokenAddress,
                    amountToPush,
                    start.toString(),
                    cliff.toString(),
                    end.toString()
                ]
            });
            usersProcessed++;
        } else if (BigInt(amountToPush) <= BigInt(0)) {
            usersSkipped++;
            console.log(`‚è≠Ô∏è  Skipping ${checksummedUserAddress}: Fully claimed (${ethers.formatEther(user.amount)} tokens)\n`);
        }
    }

    console.log('='.repeat(80));
    console.log('üìà Processing Summary:');
    console.log('='.repeat(80));
    console.log(`Total users in file: ${userData.length}`);
    console.log(`Users with claims: ${usersWithClaims}`);
    console.log(`Users without claims: ${userData.length - usersWithClaims}`);
    console.log(`Users included in output: ${usersProcessed}`);
    console.log(`Users skipped (fully claimed): ${usersSkipped}`);
    console.log(`Total amount deducted: ${ethers.formatEther(totalDeducted)} tokens\n`);

    return transactions;
}

/**
 * Generate transaction JSON files in batches
 */
function generateTransactionJson(safe, projectName, client, userData, abcTokenAddress, start, cliff, end, claimedMap, onlyUsersWithClaims) {
    const batchSize = 25;
    const currentTimestamp = Date.now();

    // Checksum the Safe address
    const checksummedSafeAddress = ethers.getAddress(safe);

    // Create project folder structure
    const projectFolder = `./${projectName}`;
    const pushPaymentFolder = `${projectFolder}/pushPayment`;

    if (!fs.existsSync(projectFolder)) {
        fs.mkdirSync(projectFolder, { recursive: true });
        console.log(`üìÅ Created project folder: ${projectFolder}`);
    }

    if (!fs.existsSync(pushPaymentFolder)) {
        fs.mkdirSync(pushPaymentFolder, { recursive: true });
        console.log(`üìÅ Created pushPayment folder: ${pushPaymentFolder}`);
    }

    // Build all transactions
    const transactions = buildTransactions(
        client,
        userData,
        abcTokenAddress,
        start,
        cliff,
        end,
        claimedMap,
        onlyUsersWithClaims
    );

    if (transactions.length === 0) {
        console.log('‚ö†Ô∏è  No transactions to generate. All users were skipped.');
        return;
    }

    // Split into batches
    const totalBatches = Math.ceil(transactions.length / batchSize);

    console.log('='.repeat(80));
    console.log('üìù Generating Transaction Files');
    console.log('='.repeat(80));
    console.log(`Total transactions: ${transactions.length}`);
    console.log(`Batch size: ${batchSize}`);
    console.log(`Total batches: ${totalBatches}\n`);

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
        const startIndex = batchIndex * batchSize;
        const endIndex = Math.min(startIndex + batchSize, transactions.length);
        const batchTransactions = transactions.slice(startIndex, endIndex);

        const transactionData = {
            version: "1.0",
            chainId: "137", // Polygon Mainnet
            createdAt: currentTimestamp,
            meta: {
                name: `[PUSH-PAYMENTS]-[${projectName}]-[WITH-DEDUCTION]-[TX-${batchIndex}]`,
                description: `Batch ${batchIndex + 1} for ${projectName} - With claim deductions`,
                txBuilderVersion: "",
                createdFromSafeAddress: checksummedSafeAddress,
                createdFromOwnerAddress: "",
                checksum: ""
            },
            transactions: batchTransactions
        };

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').replace('T', '_').slice(0, 19);
        const filename = `transactions_${projectName}_batch${batchIndex + 1}_${timestamp}.json`;
        const filePath = `${pushPaymentFolder}/${filename}`;

        fs.writeFileSync(filePath, JSON.stringify(transactionData, null, 2));
        console.log(`‚úÖ Generated: ${filename} (${batchTransactions.length} transactions)`);
    }

    console.log(`\nüéâ All transaction files generated successfully!`);
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

async function main() {
    console.log('='.repeat(80));
    console.log('Push Payment Transaction Generator with Claim Deduction');
    console.log('='.repeat(80));

    // Read transaction files
    const filesDataArray = readTransactionFiles(CONFIG.transactionFileNames);
    const filesData = filesDataArray[0]; // Use first file for configuration

    // Extract configuration from transaction file
    let projectName = filesData.projectName;
    const paymentRouterAddress = filesData.queries.addresses.paymentRouter;
    const fundingPotMSAddress = filesData.inputs.projectConfig.SAFE;
    const abcTokenAddress = filesData.queries.addresses.issuanceToken;

    // Clean up project name
    if (projectName) {
        const originalName = projectName;
        projectName = projectName.replace(/_S2$/i, '').replace(/_+$/, '');
        if (originalName !== projectName) {
            console.log(`üìù Cleaned project name: ${originalName} ‚Üí ${projectName}`);
        }
    }

    // Validate extracted data
    if (!projectName || !paymentRouterAddress || !fundingPotMSAddress || !abcTokenAddress) {
        console.error('‚ùå Error: Failed to extract all required configuration from transaction file');
        console.error('Missing:', {
            projectName: !!projectName,
            paymentRouterAddress: !!paymentRouterAddress,
            fundingPotMSAddress: !!fundingPotMSAddress,
            abcTokenAddress: !!abcTokenAddress
        });
        process.exit(1);
    }

    console.log('\n‚úÖ Project Configuration:');
    console.log(`   Project Name: ${projectName}`);
    console.log(`   Safe Address: ${fundingPotMSAddress}`);
    console.log(`   Payment Router: ${paymentRouterAddress}`);
    console.log(`   Token Address: ${abcTokenAddress}`);

    // Extract timing data from first file
    let originalStart, originalCliff, originalEnd;
    if (filesData.transactions.readable && filesData.transactions.readable.length > 0) {
        const firstTransaction = filesData.transactions.readable[0];
        if (firstTransaction && firstTransaction.length > 0) {
            const firstTx = firstTransaction.find(tx =>
                tx.functionSignature === "pushPayment(address,address,uint256,uint256,uint256,uint256)"
            );
            if (firstTx && firstTx.inputValues && firstTx.inputValues.length >= 6) {
                originalStart = parseInt(firstTx.inputValues[3]);
                originalCliff = parseInt(firstTx.inputValues[4]);
                originalEnd = parseInt(firstTx.inputValues[5]);
            }
        }
    }

    if (!originalStart || !originalEnd) {
        console.error('‚ùå Error: Failed to extract timing data from transaction file');
        process.exit(1);
    }

    // Calculate new timing
    const start = originalStart + originalCliff;
    const cliff = 0;
    const end = originalEnd;

    console.log(`\n‚è∞ Timing Configuration:`);
    console.log(`   Original Start: ${originalStart} (${new Date(originalStart * 1000).toISOString()})`);
    console.log(`   Original Cliff: ${originalCliff} seconds (${Math.floor(originalCliff / 86400)} days)`);
    console.log(`   Original End: ${originalEnd} (${new Date(originalEnd * 1000).toISOString()})`);
    console.log(`   ‚Üí New Start: ${start} (${new Date(start * 1000).toISOString()})`);
    console.log(`   ‚Üí New Cliff: ${cliff}`);
    console.log(`   ‚Üí New End: ${end} (${new Date(end * 1000).toISOString()})`);

    // Extract and merge user data from all files
    const userData = getUserDataFromMultipleFiles(filesDataArray);
    console.log(`\nüë• Users Found: ${userData.length} (merged from ${filesDataArray.length} file(s))`);

    // Read claims report
    console.log(`\nüìä Reading claims report: ${CONFIG.claimsReportFileName}`);
    const claimsReport = readClaimsReport(CONFIG.claimsReportFileName);

    // Build claimed amounts map
    const claimedMap = claimsReport ? buildClaimedAmountsMap(claimsReport, abcTokenAddress) : new Map();

    if (claimedMap.size > 0) {
        console.log(`\n‚úÖ Found ${claimedMap.size} users with claims for this token`);
    } else {
        console.log(`\n‚ö†Ô∏è  No claims found - will use original amounts for all users`);
    }

    // Generate transactions
    console.log('\n' + '='.repeat(80));
    console.log('üèóÔ∏è  Generating Transactions');
    console.log('='.repeat(80));
    console.log(`Mode: ${CONFIG.onlyUsersWithClaims ? 'Only users with claims' : 'All users (with deductions)'}`);

    generateTransactionJson(
        fundingPotMSAddress,
        projectName,
        paymentRouterAddress,
        userData,
        abcTokenAddress,
        start,
        cliff,
        end,
        claimedMap,
        CONFIG.onlyUsersWithClaims
    );

    console.log('\n‚úÖ Done!');
    console.log('='.repeat(80));
}

main().catch(error => {
    console.error('\n‚ùå Fatal Error:', error);
    process.exit(1);
});